#!/usr/bin/env bash
# Cohesion Script Header (standardized)
# Requires: bash >= 3.2 or zsh >= 5 (zsh-compatible via cohesion-utils)
set -euo pipefail

# For init command, don't load utils since we're creating a new project
if [ "${1:-}" != "init" ]; then
  _script_dir="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd -P)"
  _utils_candidates=(
    "$PWD/.claude/utils/cohesion-utils.sh"
    "$_script_dir/../.claude/utils/cohesion-utils.sh"
    "$_script_dir/../../.claude/utils/cohesion-utils.sh"
    "$_script_dir/../utils/cohesion-utils.sh"
    "$HOME/.cohesion/utils/cohesion-utils.sh"
  )
  for _u in "${_utils_candidates[@]}"; do
    # shellcheck disable=SC1090
    if [ -f "$_u" ]; then . "$_u"; _found_utils=1; break; fi
  done
  : "${_found_utils:=0}"
  if [ "$_found_utils" -eq 0 ]; then
    printf 'cohesion: missing cohesion-utils.sh\n' >&2; exit 1
  fi
  unset _script_dir _u _utils_candidates _found_utils
fi

# Initialize spinner PID as empty
_SPIN_PID=""

# Version
VERSION="1.0.0"

_spinner_start() {
  # $1: message to display
  local msg="${1:-Working...}"
  printf "%s " "$msg"
  # Simple spinner without background process for now
  _SPIN_MSG="$msg"
}

_spinner_stop() {
  # $1: ok|fail|skip (default ok)
  local s="${1:-ok}"
  [[ -n "${_SPIN_PID:-}" ]] && kill "${_SPIN_PID}" 2>/dev/null || true
  wait "${_SPIN_PID:-}" 2>/dev/null || true
  tput cnorm 2>/dev/null || true
  case "$s" in
    ok)   printf "\r%s ‚úì\n" "${_SPIN_MSG:-Done}" >&2 ;;
    fail) printf "\r%s ‚úó\n" "${_SPIN_MSG:-Failed}" >&2 ;;
    skip) printf "\r%s ‚Ä¶\n" "${_SPIN_MSG:-Skipped}" >&2 ;;
  esac
  trap - INT TERM EXIT
  unset _SPIN_PID _SPIN_MSG
}
# Run a command with spinner message:
_spin() { # _spin "Message" command [args...]
  local msg="$1"; shift
  _spinner_start "$msg"
  if "$@"; then _spinner_stop ok; else _spinner_stop fail; return 1; fi
}


# Use COHESION_HOME consistently (support COHESION_DIR for backwards compat)
: "${COHESION_HOME:=${COHESION_DIR:-$HOME/.cohesion}}"
COHESION_DIR="$COHESION_HOME"  # Keep for backwards compat
BIN_DIR="${COHESION_HOME}/bin"
MANIFEST_FILE="${COHESION_HOME}/.manifest.json"

# Use existing vars if set (may be readonly from utils), otherwise define
: "${PROJECT_DIR:=$(pwd)}"
: "${CLAUDE_DIR:=${PROJECT_DIR}/.claude}"
: "${HOOKS_DIR:=${CLAUDE_DIR}/hooks}"
: "${UTILS_DIR:=${CLAUDE_DIR}/utils}"
: "${STATE_DIR:=${CLAUDE_DIR}/state}"

# Protect wizard functions
get_patterns() {
    local category="$1"
    case "$category" in
        env)
            echo ".env .env.* secrets/ credentials/ config/secrets/"
            ;;
        deps)
            echo "node_modules/ .npm/ .yarn/ vendor/ target/ build/ dist/ .next/ .nuxt/ __pycache__/ .pytest_cache/ .tox/"
            ;;
        security)
            echo "*.key *.pem *.p12 *.pfx ~/.ssh/ .ssh/ id_rsa* id_ed25519* .gnupg/ .gpg/"
            ;;
        data)
            echo "*.sqlite *.sqlite3 *.db *.dbf database.* *.dump *.sql"
            ;;
        locks)
            echo "package-lock.json yarn.lock Pipfile.lock Gemfile.lock composer.lock pnpm-lock.yaml go.sum Cargo.lock"
            ;;
    esac
}

get_category_details() {
    local category="$1"
    case "$category" in
        env)
            echo "Environment files with API keys, passwords, tokens"
            ;;
        deps)
            echo "Package managers create these automatically"
            ;;
        security)
            echo "SSH keys, certificates, GPG keys"
            ;;
        data)
            echo "Database files that might contain sensitive data"
            ;;
        locks)
            echo "Dependency lock files (usually auto-generated)"
            ;;
    esac
}

# Use safe rm from shell safety helpers if available, otherwise inline
if ! command -v _coh_safe_rm_rf >/dev/null 2>&1; then
  _coh_safe_rm_rf() {
    local COHESION_DIR="${COHESION_DIR:-$HOME/.cohesion}"
    local PROJECT_DIR="${PROJECT_DIR:-$(pwd)}"
    
    for p in "$@"; do
      if [[ -z "$p" || "$p" == "/" || "$p" == "$HOME" || "$p" == "~" ]]; then
        printf 'Refusing to rm -rf "%s"\n' "$p" >&2
        exit 1
      fi
      case "$p" in
        "$PROJECT_DIR"/.claude*|"$COHESION_DIR"/*|/tmp/*)
          rm -rf -- "$p"
          ;;
        *)
          printf 'Refusing to rm -rf outside allowed roots: %s\n' "$p" >&2
          exit 1
          ;;
      esac
    done
  }
fi
# Alias for backward compatibility
_safe_rm_rf() { _coh_safe_rm_rf "$@"; }

show_category_details() {
    local category="$1"
    echo
    echo "  Details: $(get_category_details "$category")"
    echo "  Patterns: $(get_patterns "$category")"
    echo
}

show_category() {
    local category="$1" name="$2" emoji="$3" default="$4"
    local def_text=""
    [[ "$default" == "y" ]] && def_text=" (default: yes)" || def_text=" (default: no)"
    echo
    echo "$emoji $name$def_text"
}

run_protect_wizard() {
    local GLOBAL_PROTECTED="${COHESION_DIR}/protected.conf"
    
    echo
    echo "üõ°Ô∏è  Cohesion Protect Wizard"
    echo "     ========================"
    echo
    echo "     This wizard helps you configure which files and folders Claude Code"
    echo "     should never modify. These protections apply globally and help prevent"
    echo "     accidental changes to sensitive or important files."
    echo
    echo "     You'll be asked about different categories of files. Choose what makes"
    echo "     sense for your development workflow."
    echo
    echo "     Type 's' to see details about any category."
    echo "     Type 'y' for yes, 'n' for no, or press Enter for the default."
    echo
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo

    mkdir -p "$COHESION_DIR"
    {
      echo "# Cohesion protected paths - generated by wizard"
      echo "# Edit this file manually or run: cohesion protect --wizard"
      echo
      echo ".git/"
    } > "$GLOBAL_PROTECTED"

    # Categories to ask about
    local -a categories=(
        "env|Environment & Secrets|üîê|y"
        "deps|Dependencies & Build Output|üì¶|y" 
        "security|Security Credentials|üîë|y"
        "data|Databases & Data|üíæ|n"
        "locks|Package Manager Lockfiles|üîí|n"
    )

    for cat_info in "${categories[@]}"; do
        IFS='|' read -r category name emoji default <<< "$cat_info"
        
        while true; do
            show_category "$category" "$name" "$emoji" "$default"
            if assume_defaults; then
                choice="s"
            else
                read -p "     Protect $name? [y/n/s]: " -r choice
            fi
            
            choice_lower=$(echo "$choice" | tr '[:upper:]' '[:lower:]')
            case "$choice_lower" in
                s|show)
                    show_category_details "$category"
                    continue
                    ;;
                y|yes|'')
                    if [[ -z "$choice" && "$default" == "n" ]]; then
                        break  # Enter pressed with default no
                    fi
                    patterns="$(get_patterns "$category")"
                    echo "# $name" >> "$GLOBAL_PROTECTED"
                    for pattern in $patterns; do
                        echo "$pattern" >> "$GLOBAL_PROTECTED"
                    done
                    echo >> "$GLOBAL_PROTECTED"
                    echo "     ‚úì Added $name protections"
                    break
                    ;;
                n|no)
                    if [[ "$default" == "y" && -z "$choice" ]]; then
                        # This handles the case where Enter was pressed with default yes
                        patterns="$(get_patterns "$category")"
                        echo "# $name" >> "$GLOBAL_PROTECTED"
                        for pattern in $patterns; do
                            echo "$pattern" >> "$GLOBAL_PROTECTED"
                        done
                        echo >> "$GLOBAL_PROTECTED"
                        echo "     ‚úì Added $name protections"
                    else
                        echo "     ‚è≠  Skipped $name"
                    fi
                    break
                    ;;
                *)
                    echo "     Please enter y, n, or s"
                    ;;
            esac
        done
    done

    echo
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo

    # Ask for custom patterns
    echo "üéØ Custom Protection Patterns"
    echo
    echo "     Add any custom file patterns you want to protect:"
    echo "     (Examples: *.secret, private/, config.json)"
    echo "     Press Enter when done."
    echo

    while true; do
        if assume_defaults; then
            custom=""
        else
            read -p "     Custom pattern (or Enter to finish): " -r custom
        fi
        if [[ -z "$custom" ]]; then
            break
        fi
        {
            echo "# Custom"
            echo "$custom"
            echo
        } >> "$GLOBAL_PROTECTED"
        echo "     ‚úì Added custom pattern: $custom"
    done

    echo
    echo "üéâ Protection Configuration Complete!"
    echo
    echo "     Global config: $GLOBAL_PROTECTED"
    echo "     This will be copied to .claude/protected.conf in new projects."
    echo
    echo "     To modify protections later:"
    echo "     ‚Ä¢ Run: cohesion protect --wizard"
    echo "     ‚Ä¢ Edit: $GLOBAL_PROTECTED"
    echo
}

# --- Init Wizard Functions ---
detect_project_type() {
    local type="generic"
    
    if [ -f "package.json" ]; then
        type="node"
    elif [ -f "requirements.txt" ] || [ -f "setup.py" ] || [ -f "pyproject.toml" ]; then
        type="python"
    elif [ -f "Cargo.toml" ]; then
        type="rust"
    elif [ -f "go.mod" ]; then
        type="go"
    elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
        type="java"
    elif [ -f "Gemfile" ]; then
        type="ruby"
    elif [ -f "composer.json" ]; then
        type="php"
    fi
    
    echo "$type"
}

run_init_wizard() {
    local EXISTING_CONFIG="none"
    local MERGE_MODE=""
    
    # For init, set up directories without loading utils
    PROJECT_DIR="$(pwd)"
    CLAUDE_DIR="$PROJECT_DIR/.claude"
    COHESION_DIR="$HOME/.cohesion"
    
    # Check if already initialized
    if [ -d "$CLAUDE_DIR" ]; then
        EXISTING_CONFIG="found"
        echo
        echo "üìÅ Existing Cohesion Configuration Detected"
        echo "============================================"
        echo
        echo "Found at: $CLAUDE_DIR"
        
        # Show what exists
        echo
        echo "Existing files:"
        [ -f "$CLAUDE_DIR/settings.json" ] && echo "  ‚Ä¢ settings.json"
        [ -f "$CLAUDE_DIR/project.conf" ] && echo "  ‚Ä¢ project.conf (custom configuration)"
        [ -f "$HOOKS_DIR/protected.conf" ] && echo "  ‚Ä¢ protected.conf"
        [ -f "$PROJECT_DIR/CLAUDE.md" ] && echo "  ‚Ä¢ CLAUDE.md"
        
        echo
        echo "How would you like to proceed?"
        echo
        echo "1. Merge - Keep existing, add new features (recommended)"
        echo "2. Overwrite - Start fresh with new configuration"
        echo "3. Cancel - Leave existing configuration alone"
        echo
        if assume_defaults; then
            MERGE_MODE="1"
        else
            read -p "Choice [1]: " -r MERGE_MODE
        fi
        MERGE_MODE=${MERGE_MODE:-1}
        
        # Validate input
        if [[ ! "$MERGE_MODE" =~ ^[1-3]$ ]]; then
            echo "Invalid choice. Using default (1 - Merge)."
            MERGE_MODE="1"
        fi
        
        case "$MERGE_MODE" in
            2)
                echo "Removing existing configuration..."
                rm -rf "$CLAUDE_DIR"
                [ -f "$PROJECT_DIR/CLAUDE.md" ] && rm "$PROJECT_DIR/CLAUDE.md"
                EXISTING_CONFIG="overwrite"
                ;;
            3)
                echo "Keeping existing configuration."
                echo "Initialization cancelled."
                exit 0
                ;;
            1|*)
                echo "Merging with existing configuration..."
                EXISTING_CONFIG="merge"
                # Save existing custom protections if any
                if [ -f "$HOOKS_DIR/protected.conf" ]; then
                    cp "$HOOKS_DIR/protected.conf" "/tmp/cohesion-protected-backup-$$"
                fi
                # Save existing project.conf if any
                if [ -f "$CLAUDE_DIR/project.conf" ]; then
                    cp "$CLAUDE_DIR/project.conf" "/tmp/cohesion-project-backup-$$"
                fi
                ;;
        esac
    fi
    
    local PROJECT_TYPE
    PROJECT_TYPE=$(detect_project_type)
    local CONFIG_MODE=""
    local CUSTOM_PROTECTIONS=""
    local CUSTOM_INSTRUCTIONS=""
    local SKIP_WIZARD=false
    
    # Welcome
    echo
    echo "üéØ Cohesion Project Setup Wizard"
    echo "================================"
    echo
    echo "Project: $PROJECT_DIR"
    if [ "$PROJECT_TYPE" != "generic" ]; then
        echo "Type: $PROJECT_TYPE (auto-detected)"
    fi
    echo
    echo "This wizard will:"
    echo "‚Ä¢ Set up AI assistance for your project"
    echo "‚Ä¢ Configure file protections"
    echo "‚Ä¢ Customize instructions for Claude"
    echo
    
    if assume_defaults; then
        REPLY="y"
        SKIP_WIZARD=true
    else
        read -p "Continue with wizard? [Y/n]: " -r
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            echo "Using default configuration..."
            SKIP_WIZARD=true
        fi
    fi
    
    if [ "$SKIP_WIZARD" = false ]; then
        # Configuration choice
        echo
        echo "üìã Configuration Options"
        echo "========================"
        echo
        echo "1. Use global defaults (recommended)"
        echo "   - Inherits protections from ~/.cohesion"
        echo "   - Standard DUO protocol"
        echo "   - Quick setup"
        echo
        echo "2. Customize for this project"
        echo "   - Add project-specific protections"
        echo "   - Add custom instructions"
        echo "   - Tailored setup"
        echo
        
        if have_jq && [ -f "$MANIFEST_FILE" ]; then
            local project_count
            project_count=$(jq -r '.projects | length' "$MANIFEST_FILE" 2>/dev/null || echo "0")
            if [ "$project_count" -gt 0 ]; then
                echo "3. Clone from another project"
                echo "   - Copy settings from existing project"
                echo
            fi
        fi
        
        if assume_defaults; then
            CONFIG_MODE="1"
        else
            read -p "Choice [1]: " -r CONFIG_MODE
        fi
        CONFIG_MODE=${CONFIG_MODE:-1}
        
        # Validate input
        if [[ ! "$CONFIG_MODE" =~ ^[1-3]$ ]]; then
            echo "Invalid choice. Using default (1)."
            CONFIG_MODE="1"
        fi
        
        # Handle customization
        if [ "$CONFIG_MODE" = "2" ]; then
            # Project-specific protections
            echo
            echo "üõ°Ô∏è Protection Configuration"
            echo "==========================="
            echo
            echo "Global protections (inherited):"
            if [ -f "${COHESION_DIR}/protected.conf" ]; then
                grep -v '^#' "${COHESION_DIR}/protected.conf" | grep -v '^$' | head -5 | sed 's/^/  ‚úì /'
            else
                echo "  ‚úì .env files"
                echo "  ‚úì credentials & secrets"
            fi
            echo
            echo "Add project-specific protections?"
            echo "Example: database/, *.key, config/prod.json"
            if assume_defaults; then
                REPLY=""
            else
                read -p "Enter patterns (comma-separated, or press Enter to skip): " -r
            fi
            CUSTOM_PROTECTIONS="$REPLY"
            
            # Custom instructions
            echo
            echo "üìù Project Instructions"
            echo "======================="
            echo
            echo "Would you like to add project-specific instructions for Claude?"
            echo
            echo "1. No additional instructions"
            echo "2. Add project context (what is this project?)"
            echo "3. Add coding standards (style guide, conventions)"
            echo "4. Add both context and standards"
            echo
            if assume_defaults; then
                INST_CHOICE="1"
            else
                read -p "Choice [1]: " -r INST_CHOICE
            fi
            INST_CHOICE=${INST_CHOICE:-1}
            
            # Validate input
            if [[ ! "$INST_CHOICE" =~ ^[1-4]$ ]]; then
                echo "Invalid choice. Using default (1)."
                INST_CHOICE="1"
            fi
            
            case "$INST_CHOICE" in
                2)
                    echo
                    echo "Enter project context (or press Enter to skip):"
                    if assume_defaults; then
                        CONTEXT=""
                    else
                        read -r CONTEXT
                    fi
                    if [ -n "$CONTEXT" ]; then
                        CUSTOM_INSTRUCTIONS="## Project Context\n$CONTEXT\n"
                    fi
                    ;;
                3)
                    echo
                    echo "Enter coding standards (or press Enter to skip):"
                    if assume_defaults; then
                        STANDARDS=""
                    else
                        read -r STANDARDS
                    fi
                    if [ -n "$STANDARDS" ]; then
                        CUSTOM_INSTRUCTIONS="## Coding Standards\n$STANDARDS\n"
                    fi
                    ;;
                4)
                    echo
                    echo "Enter project context:"
                    if assume_defaults; then
                        CONTEXT=""
                    else
                        read -r CONTEXT
                    fi
                    echo "Enter coding standards:"
                    if assume_defaults; then
                        STANDARDS=""
                    else
                        read -r STANDARDS
                    fi
                    if [ -n "$CONTEXT" ] || [ -n "$STANDARDS" ]; then
                        CUSTOM_INSTRUCTIONS=""
                        [ -n "$CONTEXT" ] && CUSTOM_INSTRUCTIONS="${CUSTOM_INSTRUCTIONS}## Project Context\n$CONTEXT\n\n"
                        [ -n "$STANDARDS" ] && CUSTOM_INSTRUCTIONS="${CUSTOM_INSTRUCTIONS}## Coding Standards\n$STANDARDS\n"
                    fi
                    ;;
            esac
        elif [ "$CONFIG_MODE" = "3" ] && have_jq && [ -f "$MANIFEST_FILE" ]; then
            # Clone from another project
            echo
            echo "Select project to clone from:"
            echo
            local i=1
            local -a projects=()
            while IFS= read -r proj; do
                echo "$i. $proj"
                projects+=("$proj")
                ((i++))
            done < <(jq -r '.projects | keys[]' "$MANIFEST_FILE" 2>/dev/null | grep -v "^$PROJECT_DIR$")
            
            if assume_defaults; then
                CLONE_CHOICE=""
            else
                read -p "Choice: " -r CLONE_CHOICE
            fi
            if [ -n "$CLONE_CHOICE" ] && [ "$CLONE_CHOICE" -ge 1 ] && [ "$CLONE_CHOICE" -le "${#projects[@]}" ]; then
                local SOURCE_PROJECT="${projects[$((CLONE_CHOICE-1))]}"
                echo "Cloning configuration from: $SOURCE_PROJECT"
                # This would copy settings from the source project
                # Implementation depends on how we store project configs
            fi
        fi
    fi
    
    # Summary
    echo
    echo "‚úÖ Ready to Initialize"
    echo "======================"
    echo
    echo "Configuration Summary:"
    echo "‚Ä¢ Project: $PROJECT_DIR"
    if [ "$CONFIG_MODE" = "2" ]; then
        echo "‚Ä¢ Config: Customized"
        [ -n "$CUSTOM_PROTECTIONS" ] && echo "‚Ä¢ Extra protections: $CUSTOM_PROTECTIONS"
        [ -n "$CUSTOM_INSTRUCTIONS" ] && echo "‚Ä¢ Custom instructions: Added"
    else
        echo "‚Ä¢ Config: Using global defaults"
    fi
    echo
    echo "This will create:"
    echo "‚Ä¢ .claude/ directory with hooks and settings"
    echo "‚Ä¢ CLAUDE.md with DUO protocol instructions"
    echo "‚Ä¢ Entry in global manifest"
    echo
    
    if assume_defaults; then
        REPLY="y"
    else
        read -p "Initialize with these settings? [Y/n]: " -r
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            echo "Initialization cancelled."
            exit 0
        fi
    fi
    
    # Perform the actual initialization
    echo
    if [ "$EXISTING_CONFIG" = "merge" ]; then
        echo "Updating Cohesion in: $PROJECT_DIR"
    else
        echo "Initializing Cohesion in: $PROJECT_DIR"
    fi
    
    ensure_dirs
    _spin "Updating hooks" _copy_tree "${COHESION_DIR}/hooks" "$HOOKS_DIR"
    _spin "Updating utils" _copy_tree "${COHESION_DIR}/utils" "$UTILS_DIR"
    # Ensure hook scripts are executable (critical for functionality)
    if ! chmod +x "$HOOKS_DIR"/*.sh 2>/dev/null; then
        echo "‚ùå WARNING: Failed to make hook scripts executable in $HOOKS_DIR"
        echo "Manual fix: chmod +x $HOOKS_DIR/*.sh"
    fi
    
    # Copy command scripts (slash commands)
    if [ -d "${COHESION_DIR}/templates/.claude/commands" ]; then
        echo "  Installing slash commands..."
        if ! cp -r "${COHESION_DIR}/templates/.claude/commands" "$CLAUDE_DIR/"; then
            echo "‚ö†Ô∏è  WARNING: Failed to copy slash commands from ${COHESION_DIR}/templates/.claude/commands"
            echo "   Mode switching will not work properly"
            echo "   Recovery: Run 'cohesion doctor' to repair"
        else
            echo "  ‚úì Slash commands installed"
        fi
    else
        echo "‚ö†Ô∏è  WARNING: Command templates directory not found at ${COHESION_DIR}/templates/.claude/commands"
        echo "   Slash commands will not be available"
        echo "   Recovery: Reinstall Cohesion or run 'cohesion doctor'"
    fi
    
    # Copy canon
    if [ -d "${COHESION_DIR}/templates/.claude/cohesion-canon" ]; then
        echo "  Installing Canon principles..."
        cp -r "${COHESION_DIR}/templates/.claude/cohesion-canon" "$CLAUDE_DIR/"
        echo "  ‚úì Canon installed"
    fi
    
    # Copy canon cache
    if [ -f "${COHESION_DIR}/templates/.claude/canon-cache.md" ]; then
        cp "${COHESION_DIR}/templates/.claude/canon-cache.md" "$CLAUDE_DIR/"
    fi
    
    # Handle protected.conf based on merge mode
    if [ "$EXISTING_CONFIG" = "merge" ]; then
        # Merge: Keep existing protections, add any new global ones
        if [ -f "/tmp/cohesion-protected-backup-$$" ]; then
            # Start with global protections
            [ -f "${COHESION_DIR}/protected.conf" ] && cp "${COHESION_DIR}/protected.conf" "$HOOKS_DIR/protected.conf"
            
            # Append existing custom protections
            echo "" >> "$HOOKS_DIR/protected.conf"
            echo "# Existing project-specific protections (preserved)" >> "$HOOKS_DIR/protected.conf"
            grep -v '^#' "/tmp/cohesion-protected-backup-$$" | grep -v '^$' >> "$HOOKS_DIR/protected.conf" 2>/dev/null || true
            rm "/tmp/cohesion-protected-backup-$$"
        else
            if [ -f "${COHESION_DIR}/protected.conf" ]; then
                if ! cp "${COHESION_DIR}/protected.conf" "$HOOKS_DIR/"; then
                    echo "‚ùå WARNING: Failed to copy protection config to $HOOKS_DIR/"
                    echo "Security protections may not be active"
                fi
            fi
        fi
    else
        # Fresh install: Copy global protections
        if [ -f "${COHESION_DIR}/protected.conf" ]; then
            if ! cp "${COHESION_DIR}/protected.conf" "$HOOKS_DIR/"; then
                echo "‚ùå WARNING: Failed to copy protection config to $HOOKS_DIR/"
                echo "Security protections may not be active"
            fi
        fi
    fi
    
    # Add NEW custom protections if specified
    if [ -n "$CUSTOM_PROTECTIONS" ]; then
        echo >> "$HOOKS_DIR/protected.conf"
        echo "# New project-specific protections" >> "$HOOKS_DIR/protected.conf"
        IFS=',' read -ra PATTERNS <<< "$CUSTOM_PROTECTIONS"
        for pattern in "${PATTERNS[@]}"; do
            echo "${pattern// /}" >> "$HOOKS_DIR/protected.conf"
        done
    fi
    
    # Handle settings files - ALL THREE ARE REQUIRED FOR DUO PROTOCOL
    # The system MUST have all three settings files or it won't work properly
    
    if [ "$EXISTING_CONFIG" = "merge" ]; then
        echo "Verifying DUO protocol settings..."
        
        # --- Begin: root settings promotion/migration (merge path) ---
        # Normalize root settings to settings.local.json early so later logic is consistent.
        if [ -f "${CLAUDE_DIR}/settings.json" ] && [ ! -f "${CLAUDE_DIR}/settings.local.json" ]; then
            mv "${CLAUDE_DIR}/settings.json" "${CLAUDE_DIR}/settings.local.json"
            echo "  ‚úì Migrated settings.json ‚Üí settings.local.json"
        elif [ ! -f "${CLAUDE_DIR}/settings.local.json" ]; then
            if [ -f "${COHESION_DIR}/templates/.claude/settings.local.json" ]; then
                cp "${COHESION_DIR}/templates/.claude/settings.local.json" "${CLAUDE_DIR}/settings.local.json"
                echo "  ‚úì Added settings.local.json from template"
            fi
        fi
        # --- End: root settings promotion/migration (merge path) ---
        
        # Check and report what's missing
        local settings_missing=false
        if [ ! -f "$CLAUDE_DIR/settings.local.json" ]; then
            settings_missing=true
            echo "  ‚ö†Ô∏è  Missing settings.local.json (main settings file)"
        fi
        [ ! -f "$CLAUDE_DIR/settings.json" ] && settings_missing=true && echo "  ‚ö†Ô∏è  Missing settings.json (base configuration)"
        # Mode-specific settings files no longer required - hooks enforce restrictions
        
        if [ "$settings_missing" = true ]; then
            echo "  üîß Repairing incomplete DUO protocol settings..."
        fi
        
        # Ensure settings exist
        
        if [ ! -f "$CLAUDE_DIR/settings.json" ]; then
            if [ -f "${COHESION_DIR}/templates/.claude/settings.json" ]; then
                cp "${COHESION_DIR}/templates/.claude/settings.json" "$CLAUDE_DIR/settings.json"
                echo "  ‚úì Added cohesion settings.json (DISCOVER mode)"
            fi
        else
            echo "  ‚úì cohesion settings.json present"
        fi
        
        # ALWAYS update or add unleash/optimize settings (they work as a set)
        # Mode-specific settings no longer needed - using hook-based enforcement
        
        # Ensure/repair root settings with DISCOVER mode (idempotent in repair path)
        if [ ! -f "$CLAUDE_DIR/settings.local.json" ]; then
            if [ -f "$CLAUDE_DIR/settings.json" ]; then
                cp "$CLAUDE_DIR/settings.json" "$CLAUDE_DIR/settings.local.json"
                echo "  ‚úì Ensured settings.local.json present (DISCOVER mode)"
            elif [ -f "${COHESION_DIR}/templates/.claude/settings.local.json" ]; then
                cp "${COHESION_DIR}/templates/.claude/settings.local.json" "$CLAUDE_DIR/settings.local.json"
                echo "  ‚úì Ensured settings.local.json present (generic template)"
            fi
        fi
        
        echo "‚úì DUO protocol settings complete"
    else
        # Fresh install: Copy ALL settings (required for system to work)
        echo "Installing DUO protocol settings..."
        
        # Settings will be placed directly in .claude/
        
        if [ -f "${COHESION_DIR}/templates/.claude/settings.json" ]; then
            cp "${COHESION_DIR}/templates/.claude/settings.json" "$CLAUDE_DIR/settings.json"
        elif [ -f "${COHESION_DIR}/settings.json" ]; then
            cp "${COHESION_DIR}/settings.json" "$CLAUDE_DIR/settings.json"
        fi
        
        # Mode-specific settings no longer needed - hooks enforce restrictions
        # Legacy code removed: We used to copy settings.unleash.json and settings.optimize.json
        # Now we use a single settings.local.json with bypassPermissions
        # and hooks check state files to enforce mode restrictions
        
        echo "‚úì Settings configured (hooks enforce mode restrictions)"
        
        # Initialize with universal settings (hooks enforce mode restrictions)
        if [ -f "${COHESION_DIR}/templates/.claude/settings.local.json" ]; then
            cp "${COHESION_DIR}/templates/.claude/settings.local.json" "$CLAUDE_DIR/settings.local.json"
            echo "‚úì Created settings.local.json (hooks enforce mode restrictions)"
        fi
    fi
    
    # Handle CLAUDE.md based on merge mode
    if [ "$EXISTING_CONFIG" = "merge" ]; then
        # Merge mode: Only add if missing, or append custom instructions
        if [ ! -f "${PROJECT_DIR}/CLAUDE.md" ]; then
            if [ -f "${COHESION_DIR}/templates/CLAUDE.md" ]; then
                cp "${COHESION_DIR}/templates/CLAUDE.md" "${PROJECT_DIR}/CLAUDE.md"
                echo "‚úì Added CLAUDE.md with DUO protocol instructions"
            fi
        fi
        
        # Append new custom instructions to existing CLAUDE.md
        if [ -n "$CUSTOM_INSTRUCTIONS" ] && [ -f "${PROJECT_DIR}/CLAUDE.md" ]; then
            {
                echo
                echo "---"
                echo "# Additional Project Instructions ($(date +%Y-%m-%d))"
                echo -e "$CUSTOM_INSTRUCTIONS"
            } >> "${PROJECT_DIR}/CLAUDE.md"
            echo "‚úì Appended custom instructions to existing CLAUDE.md"
        fi
    else
        # Fresh install: Create new CLAUDE.md
        if [ ! -f "${PROJECT_DIR}/CLAUDE.md" ]; then
            if [ -f "${COHESION_DIR}/templates/CLAUDE.md" ]; then
                cp "${COHESION_DIR}/templates/CLAUDE.md" "${PROJECT_DIR}/CLAUDE.md"
                
                # Append custom instructions if any
                if [ -n "$CUSTOM_INSTRUCTIONS" ]; then
                    {
                        echo
                        echo "---"
                        echo
                        echo -e "$CUSTOM_INSTRUCTIONS"
                    } >> "${PROJECT_DIR}/CLAUDE.md"
                fi
                
                echo "‚úì Added CLAUDE.md with DUO protocol instructions"
            fi
        fi
    fi
    
    # Store project configuration
    if [ "$CONFIG_MODE" = "2" ] || [ -n "$CUSTOM_PROTECTIONS" ] || [ -n "$CUSTOM_INSTRUCTIONS" ]; then
        cat > "$CLAUDE_DIR/project.conf" <<EOF
{
  "project_type": "$PROJECT_TYPE",
  "custom_protections": "$(echo "$CUSTOM_PROTECTIONS" | sed 's/,/", "/g' | sed 's/^/["/' | sed 's/$/"]/' | sed 's/\[""\]/[]/')",
  "customized": true,
  "initialized_at": "$(date -u +%FT%TZ)"
}
EOF
    fi
    
    update_manifest_project_add
    append_gitignore_fragment
    _spin "Setting up docs" docs_auto_init "${DOCS_DIR_FLAG:-}" "${DOCS_SOURCE_FLAG:-}"
    
    # Set initial DISCOVER state for proper first session
    mkdir -p "$PROJECT_DIR/.claude/state"
    # Create proper state file with philosophy content (matches set_mode() format)
    cat > "$PROJECT_DIR/.claude/state/DISCOVER" << 'EOF'
Mode: DISCOVER - Understanding before action
Philosophy: 10 minutes thinking = 1 hour saved
Remember: The best code is written in your mind first
EOF
    
    if [ "$EXISTING_CONFIG" = "merge" ]; then
        echo "‚úì Configuration updated (merged with existing)"
    else
        echo "‚úì Initialized"
    fi
    
    # Next steps
    echo
    echo "üìö Next steps:"
    if [ "$EXISTING_CONFIG" = "merge" ]; then
        echo "  Your existing configuration has been preserved and updated."
        echo "  New features and improvements have been added."
    fi
    echo "  1. Tell Claude about your project goals"
    echo "  2. Use 'approved' to enter UNLEASH mode for coding"
    echo "  3. Use 'cohesion status' to check current state"
    echo "  4. Run 'cohesion doctor' if you encounter issues"
    echo
}

# --- helpers ---
assume_defaults() { [ "${COHESION_ASSUME_DEFAULTS:-0}" = "1" ]; }
have_jq(){ command -v jq >/dev/null 2>&1; }
ensure_dirs(){ mkdir -p "$HOOKS_DIR" "$UTILS_DIR" "$STATE_DIR"; }
_have_rsync(){ command -v rsync >/dev/null 2>&1; }

project_state() {
  if   [ -f "$STATE_DIR/UNLEASHED" ]; then printf 'UNLEASH\n'
  elif [ -f "$STATE_DIR/OPTIMIZE"  ]; then printf 'OPTIMIZE\n'
  else                                      printf 'DISCOVER\n'
  fi
}

# Use safe copy from shell safety helpers if available
if ! command -v _coh_copy_tree >/dev/null 2>&1; then
  _copy_tree(){ # rsync if present, else cp -R
    src="$1"; dst="$2"
    mkdir -p "$dst"
    
    # Ensure source exists
    if [ ! -d "$src" ]; then
      echo "Warning: Source directory $src does not exist"
      return 1
    fi
    
    # Use rsync if available, otherwise use cp
    if _have_rsync; then 
      rsync -a "$src/" "$dst/" 2>/dev/null || cp -R "$src/." "$dst/" 2>/dev/null || true
    else 
      # Try different cp variations for cross-platform compatibility
      cp -R "$src/." "$dst/" 2>/dev/null || \
      cp -r "$src/"* "$dst/" 2>/dev/null || \
      cp -a "$src/"* "$dst/" 2>/dev/null || true
    fi
  }
else
  _copy_tree() { _coh_copy_tree "$@"; }
fi

# _docs_create_fallback removed - templates/docs is now required in v1.0.0+

_docs_write_env(){
  claude_dir="$1"; docs_dir="$2"; allow="$3"
  mkdir -p "$claude_dir"
  {
    echo "# Generated by cohesion init"
    echo "DOCS_DIR=\"$docs_dir\""
    echo "ALLOW_DISCOVER_DOC_WRITES=$allow"
  } > "$claude_dir/docs.env"
}

append_gitignore_fragment() {
  gi="$PROJECT_DIR/.gitignore"
  frag="$COHESION_DIR/templates/.gitignore.cohesion"
  [ -f "$frag" ] || return 0
  touch "$gi"
  if ! grep -q '### Cohesion (.claude) ###' "$gi"; then
    printf '\n' >> "$gi"
    cat "$frag" >> "$gi"
  fi
}

update_manifest_project_add() {
  [ -f "$MANIFEST_FILE" ] || return 0
  have_jq || return 0
  ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  tmp="${MANIFEST_FILE}.tmp"
  jq --arg proj "$PROJECT_DIR" --arg time "$ts" \
     '.projects[$proj] = {"installed_at": $time}' \
     "$MANIFEST_FILE" > "$tmp" && mv "$tmp" "$MANIFEST_FILE"
}

update_manifest_project_del() {
  [ -f "$MANIFEST_FILE" ] || return 0
  have_jq || return 0
  tmp="${MANIFEST_FILE}.tmp"
  jq --arg proj "$PROJECT_DIR" 'del(.projects[$proj])' \
     "$MANIFEST_FILE" > "$tmp" && mv "$tmp" "$MANIFEST_FILE"
}

docs_auto_init(){ # docs_auto_init [docs_dir] [source: template|create-this]
  docs_dir_in="${1:-}"
  source_in="${2:-}"

  if [ -n "${docs_dir_in}" ]; then target="${docs_dir_in}"; else target="${PROJECT_DIR}/docs"; fi
  mkdir -p "$target"

  source="$source_in"
  if [ -z "$source" ]; then source="template"; fi

  if [ "$source" = "template" ]; then
    tpl="$COHESION_DIR/templates/docs/cohesion-core-workflow"
    if [ -d "$tpl" ] && [ -n "$(ls -A "$tpl" 2>/dev/null || true)" ]; then
      _copy_tree "$tpl" "$target"
    else
      echo "‚ùå ERROR: Documentation templates not found at $tpl"
      echo "   This is required for Cohesion v1.0.0+"
      echo "   Recovery: Reinstall Cohesion or run 'cohesion doctor'"
      return 1
    fi
  else
    # Create minimal structure if explicitly requested (not template mode)
    echo "‚ö†Ô∏è  WARNING: Creating minimal docs structure without templates"
    mkdir -p "$target"
    echo "# Project Documentation" > "$target/README.md"
  fi

  _docs_write_env "$CLAUDE_DIR" "$target" 1
}

cmd="${1:-help}"
case "$cmd" in
  status)
    echo "Cohesion Status"
    echo "==============="
    echo "Binary:   $(command -v cohesion || printf '%s' "$0")"
    if [ -f "$MANIFEST_FILE" ] && have_jq; then
      printf "Version:  "; jq -r '.version // "unknown"' "$MANIFEST_FILE" || echo "unknown"
      printf "Globals:  "; jq -r '.global_files | length // 0' "$MANIFEST_FILE" || echo "0"
    else
      echo "Version:  (manifest missing or jq not installed)"
    fi
    if [ -d "$CLAUDE_DIR" ]; then
      echo "Project:  $PROJECT_DIR"
      echo "State:    $(project_state)"
      [ -d "$HOOKS_DIR" ] && echo "Hooks:    present" || echo "Hooks:    missing"
      [ -f "$UTILS_DIR/cohesion-utils.sh" ] && echo "Utils:    present" || echo "Utils:    missing"
      if [ -f "$CLAUDE_DIR/docs.env" ]; then
        docs_rel="$(grep -E '^DOCS_DIR=' "$CLAUDE_DIR/docs.env" | cut -d= -f2- | tr -d '"' || true)"
        [ -n "${docs_rel:-}" ] && echo "Docs:     ${docs_rel}"
      fi
    else
      echo "Project:  not initialized (.claude missing)"
    fi
    ;;

  init)
    shift || true
    
    # Check for help flag
    if [ "${1:-}" = "--help" ]; then
      cat <<EOF
Usage: cohesion init [options]

Initialize Cohesion in the current project directory.

Options:
  --help            Show this help message
  --assume-defaults Use default configuration without prompts
  
The init command runs an interactive wizard to help you:
  ‚Ä¢ Detect your project type
  ‚Ä¢ Configure file protections
  ‚Ä¢ Add custom instructions for Claude
  ‚Ä¢ Choose configuration approach

Examples:
  cohesion init                 # Start the interactive wizard
  cohesion init --assume-defaults  # Use defaults without prompts

For more information, visit: https://github.com/yourusername/cohesion
EOF
      exit 0
    fi
    
    # Check for --assume-defaults flag
    if [ "${1:-}" = "--assume-defaults" ]; then
      export COHESION_ASSUME_DEFAULTS=1
    fi
    
    # ALWAYS run the wizard - this is the core experience
    run_init_wizard
    ;;

  uninstall)
    if [ "${2:-}" = "--help" ]; then
      echo "Usage: cohesion uninstall [options]"
      echo ""
      echo "Remove Cohesion from the current project or globally"
      echo ""
      echo "Options:"
      echo "  --global    Remove global Cohesion installation"
      echo "  --help      Show this help message"
      echo ""
      echo "Without options, removes Cohesion from the current project only."
      exit 0
    fi
    
    if [ "${2:-}" = "--global" ] || [ "${2:-}" = "global" ]; then
      if [ -x "${BIN_DIR}/cohesion-uninstall-global.sh" ]; then
        exec "${BIN_DIR}/cohesion-uninstall-global.sh"
      else
        echo "Global uninstall script not found at ${BIN_DIR}/cohesion-uninstall-global.sh"
        exit 1
      fi
    fi
    
    # Confirmation prompt for project uninstall
    echo "‚ö†Ô∏è  This will remove Cohesion from: $PROJECT_DIR"
    echo ""
    echo "This will delete:"
    echo "  ‚Ä¢ .claude/ directory and all its contents"
    echo "  ‚Ä¢ All hooks and state information"
    echo ""
    read -p "Continue with uninstall? [y/N] " -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      echo "Uninstall cancelled."
      exit 0
    fi
    
    echo "Uninstalling from: $PROJECT_DIR"
    
    # Remove the entire .claude directory
    if [ -d "$PROJECT_DIR/.claude" ]; then
      rm -rf "$PROJECT_DIR/.claude"
      echo "  ‚úì Removed .claude directory"
    fi
    
    # Remove Cohesion section from CLAUDE.md if it exists
    if [ -f "$PROJECT_DIR/CLAUDE.md" ]; then
      if grep -q "Cohesion DUO Protocol" "$PROJECT_DIR/CLAUDE.md"; then
        # Remove Cohesion section (from # Cohesion DUO Protocol to end of file)
        sed -i.cohesion-backup '/# Cohesion DUO Protocol/,$d' "$PROJECT_DIR/CLAUDE.md" 2>/dev/null || true
        echo "  ‚úì Removed Cohesion section from CLAUDE.md"
      fi
    fi
    
    update_manifest_project_del
    echo "‚úì Project uninstall complete"
    ;;

  protect)
    if [ "${2:-}" = "--wizard" ]; then
      run_protect_wizard
    else
      echo "Usage: cohesion protect --wizard"
      exit 2
    fi
    ;;

  doctor)
    # Run doctor script
    if [ -x "${COHESION_DIR}/scripts/cohesion-doctor.sh" ]; then
      exec "${COHESION_DIR}/scripts/cohesion-doctor.sh" "$@"
    elif [ -x "${BIN_DIR}/cohesion-doctor.sh" ]; then
      exec "${BIN_DIR}/cohesion-doctor.sh" "$@"
    elif [ -x "${COHESION_DIR}/scripts/cohesion-doctor.sh" ]; then
      exec "${COHESION_DIR}/scripts/cohesion-doctor.sh" "$@"
    else
      echo "Doctor script not found (expected in ${BIN_DIR} or ${COHESION_DIR}/scripts)"
      exit 1
    fi
    ;;

  learn)
    # Run the cohesion learn interactive tutorial
    if [[ -x "$HOME/.cohesion/scripts/cohesion-learn.sh" ]]; then
      "$HOME/.cohesion/scripts/cohesion-learn.sh" "$@"
    elif [[ -x "$COHESION_DIR/scripts/cohesion-learn.sh" ]]; then
      "$COHESION_DIR/scripts/cohesion-learn.sh" "$@"
    else
      echo "‚ùå Cohesion Learn not found"
      echo "Try reinstalling Cohesion: cohesion init"
      exit 1
    fi
    ;;
  help|--help|-h)
    echo "Cohesion v$VERSION - AI Development Without the Chaos"
    echo ""
    echo "Usage: cohesion <command> [options]"
    echo ""
    echo "Commands:"
    echo "  status              Show current Cohesion state and mode"
    echo "  init                Initialize Cohesion in current project"
    echo "  learn               Interactive tutorial on Canon methodologies"
    echo "  doctor              Diagnose and auto-repair issues"
    echo "  protect --wizard    Configure protected paths interactively"
    echo "  uninstall           Remove Cohesion from project"
    echo "  uninstall --global  Remove Cohesion completely"
    echo "  help                Show this help message"
    echo ""
    echo "Learn more: https://github.com/khenbest/Cohesion"
    exit 0
    ;;
  *)
    echo "Usage: cohesion {status|init|learn|doctor|protect --wizard|uninstall [--global]|help}"
    echo "Try 'cohesion help' for more information"
    exit 2
    ;;
esac
